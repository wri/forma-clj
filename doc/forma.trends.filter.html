<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>forma.trends.filter documentation</title></head><body><div id="header"><h1><a href="index.html">Forma 0.8.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="forma.classify.logistic.html"><span>forma.classify.logistic</span></a></li><li><a href="forma.date-time.html"><span>forma.date-time</span></a></li><li><a href="forma.gfw.cdm.html"><span>forma.gfw.cdm</span></a></li><li><a href="forma.hadoop.cli.html"><span>forma.hadoop.cli</span></a></li><li><a href="forma.hadoop.io.html"><span>forma.hadoop.io</span></a></li><li><a href="forma.hadoop.jobs.cdm.html"><span>forma.hadoop.jobs.cdm</span></a></li><li><a href="forma.hadoop.jobs.forma.html"><span>forma.hadoop.jobs.forma</span></a></li><li><a href="forma.hadoop.jobs.modis.html"><span>forma.hadoop.jobs.modis</span></a></li><li><a href="forma.hadoop.jobs.neighbors.html"><span>forma.hadoop.jobs.neighbors</span></a></li><li><a href="forma.hadoop.jobs.preprocess.html"><span>forma.hadoop.jobs.preprocess</span></a></li><li><a href="forma.hadoop.jobs.scatter.html"><span>forma.hadoop.jobs.scatter</span></a></li><li><a href="forma.hadoop.jobs.timeseries.html"><span>forma.hadoop.jobs.timeseries</span></a></li><li><a href="forma.hadoop.pail.html"><span>forma.hadoop.pail</span></a></li><li><a href="forma.hadoop.predicate.html"><span>forma.hadoop.predicate</span></a></li><li><a href="forma.hoptree.html"><span>forma.hoptree</span></a></li><li><a href="forma.matrix.utils.html"><span>forma.matrix.utils</span></a></li><li><a href="forma.matrix.walk.html"><span>forma.matrix.walk</span></a></li><li><a href="forma.ops.classify.html"><span>forma.ops.classify</span></a></li><li><a href="forma.playground.html"><span>forma.playground</span></a></li><li><a href="forma.postprocess.output.html"><span>forma.postprocess.output</span></a></li><li><a href="forma.reproject.html"><span>forma.reproject</span></a></li><li><a href="forma.schema.html"><span>forma.schema</span></a></li><li><a href="forma.source.fire.html"><span>forma.source.fire</span></a></li><li><a href="forma.source.gadmiso.html"><span>forma.source.gadmiso</span></a></li><li><a href="forma.source.hdf.html"><span>forma.source.hdf</span></a></li><li><a href="forma.source.rain.html"><span>forma.source.rain</span></a></li><li><a href="forma.source.static.html"><span>forma.source.static</span></a></li><li><a href="forma.source.tilesets.html"><span>forma.source.tilesets</span></a></li><li><a href="forma.static.html"><span>forma.static</span></a></li><li><a href="forma.testing.html"><span>forma.testing</span></a></li><li><a href="forma.thrift.html"><span>forma.thrift</span></a></li><li><a href="forma.trends.analysis.html"><span>forma.trends.analysis</span></a></li><li class="current"><a href="forma.trends.filter.html"><span>forma.trends.filter</span></a></li><li><a href="forma.trends.stretch.html"><span>forma.trends.stretch</span></a></li><li><a href="forma.utils.html"><span>forma.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="forma.trends.filter.html#var-apply-to-valid"><span>apply-to-valid</span></a></li><li><a href="forma.trends.filter.html#var-bad-ends"><span>bad-ends</span></a></li><li><a href="forma.trends.filter.html#var-deseasonalize"><span>deseasonalize</span></a></li><li><a href="forma.trends.filter.html#var-dummy-mat"><span>dummy-mat</span></a></li><li><a href="forma.trends.filter.html#var-harmonic-seasonal-decomposition"><span>harmonic-seasonal-decomposition</span></a></li><li><a href="forma.trends.filter.html#var-harmonic-series"><span>harmonic-series</span></a></li><li><a href="forma.trends.filter.html#var-hp-filter"><span>hp-filter</span></a></li><li><a href="forma.trends.filter.html#var-hp-mat"><span>hp-mat</span></a></li><li><a href="forma.trends.filter.html#var-interpolate"><span>interpolate</span></a></li><li><a href="forma.trends.filter.html#var-k-harmonic-matrix"><span>k-harmonic-matrix</span></a></li><li><a href="forma.trends.filter.html#var-make-clean"><span>make-clean</span></a></li><li><a href="forma.trends.filter.html#var-make-reliable"><span>make-reliable</span></a></li><li><a href="forma.trends.filter.html#var-mask"><span>mask</span></a></li><li><a href="forma.trends.filter.html#var-neutralize-ends"><span>neutralize-ends</span></a></li><li><a href="forma.trends.filter.html#var-reliable%3F"><span>reliable?</span></a></li><li><a href="forma.trends.filter.html#var-replace-index-set"><span>replace-index-set</span></a></li><li><a href="forma.trends.filter.html#var-shorten-ts"><span>shorten-ts</span></a></li><li><a href="forma.trends.filter.html#var-stretch-ts"><span>stretch-ts</span></a></li><li><a href="forma.trends.filter.html#var-tele-ts"><span>tele-ts</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>forma.trends.filter documentation</h2><pre class="doc"></pre><div class="public" id="var-apply-to-valid"><h3>apply-to-valid</h3><div class="usage"><code>(apply-to-valid f coll)</code></div><pre class="doc">apply function `f` to all valid (non-nil) values within a collection `coll`
</pre></div><div class="public" id="var-bad-ends"><h3>bad-ends</h3><div class="usage"><code>(bad-ends bad-set coll)</code></div><pre class="doc">make a set of indices of a collection `coll` for which there are
continuous *bad* values, given by the set of values in `bad-set`
which serves as a predicate function to (effectively) filter `coll`
on the ends.  If there are no bad values on either end, then the
function will return an empty set.</pre></div><div class="public" id="var-deseasonalize"><h3>deseasonalize</h3><div class="usage"><code>(deseasonalize freq ts)</code></div><pre class="doc">accepts a timeseries `ts` with frequency `freq` and returns a
vector with the seasonal component removed; the returned vector is
only the trend component and the idiosyncratic disturbance of the
original time series.

Precondition avoids singular matrix by throwing exception
when `ts` is shorter than `freq`. Throws an exception - due to meaningless
results - if `freq` equals 1 or in case we see `nil` as the `ts`.

Example:
  (deseasonalize 23 (s/sample-uniform 200))</pre></div><div class="public" id="var-dummy-mat"><h3>dummy-mat</h3><div class="usage"><code>(dummy-mat freq n)</code></div><pre class="doc">returns an incanter matrix of `n` cycling identity matrices of
dimension `freq`, used as the cofactor matrix for deseasonalizing a
time series.

Example:
  (dummy-mat 23 (count (s/sample-normal 100)))
  ;; 23: frequency of 16-day MODIS data
  ;; 12: frequency of 32-day MODIS data</pre></div><div class="public" id="var-harmonic-seasonal-decomposition"><h3>harmonic-seasonal-decomposition</h3><div class="usage"><code>(harmonic-seasonal-decomposition freq k coll)</code></div><pre class="doc">returns a deseasonalized time-series; input frequency of
data (e.g., 23 for 16-day intervals), number of harmonic terms (use
3 to replicate procedure in the Verbesselt (2010)), and the
time-series.

Reference:
Verbesselt, J. et al. (2010) Phenological Change Detection while
Accounting for Abrupt and Gradual Trends in Satellite Image Time
Series, Remote Sensing of Environment, 114(12), 2970-298</pre></div><div class="public" id="var-harmonic-series"><h3>harmonic-series</h3><div class="usage"><code>(harmonic-series freq coll k)</code></div><pre class="doc">returns a vector of scaled cosine and sine series of the same
length as `coll`; the scalar is the harmonic coefficient</pre></div><div class="public" id="var-hp-filter"><h3>hp-filter</h3><div class="usage"><code>(hp-filter lambda ts)</code></div><pre class="doc">return a smoothed time series, given the original time series and
 H-P filter parameter (lambda); from the following reference, we calculate
 inv(lambdaF + I)*y

Reference: http://goo.gl/VC7jJ</pre></div><div class="public" id="var-hp-mat"><h3>hp-mat</h3><div class="usage"><code>(hp-mat T)</code></div><pre class="doc">returns the matrix of coefficients from the minimization problem
required to parse the trend component from a time-series of length
`T`, which has to be greater than or equal to 9 periods.</pre></div><div class="public" id="var-interpolate"><h3>interpolate</h3><div class="usage"><code>(interpolate x1 x2 length)</code></div><pre class="doc">calculate a linear interpolation between `x1` and `x2` with the specified
`length` between them.</pre></div><div class="public" id="var-k-harmonic-matrix"><h3>k-harmonic-matrix</h3><div class="usage"><code>(k-harmonic-matrix freq k coll)</code></div><pre class="doc">returns an N x (2*k) matrix of harmonic series, where N is the
length of `coll` and `k` is the number of harmonic terms.</pre></div><div class="public" id="var-make-clean"><h3>make-clean</h3><div class="usage"><code>(make-clean freq good-set bad-set spectral-ts reli-ts)</code></div><pre class="doc">Wrapper for `make-reliable`, `deseasonalize` and any future data cleaning
functions we decide to include. See `make-reliable` and `deseasonalize` for
further documentation. We use round to remove unwarranted numerical precision
from cleaned timeseries values.</pre></div><div class="public" id="var-make-reliable"><h3>make-reliable</h3><div class="usage"><code>(make-reliable good-set bad-set value-coll quality-coll)</code></div><pre class="doc">Cleans up a timeseries by replacing or interpolating over low-quality
 or unreliable values, such as those with cloud contamination. `good-set`
 and `bad-set` are Clojure sets used to identify good and bad values.

This function has two parts: (1) replace bad values at the ends
with the average of the reliable values in the target coll,
`value-coll`. (2) smooth over *bad* values, given by `bad-set`,
which are determined based on the reliability (or quality)
collection, `quality-coll`.  The `good-set` parameter is a set of
passable values, presumably interchangeable.  If this assumption is
not true, then an adjustment will have to be made to this function.</pre></div><div class="public" id="var-mask"><h3>mask</h3><div class="usage"><code>(mask pred coll-a coll-b)</code></div><pre class="doc">Apply `pred` to `coll-a` to create a mask over `coll-b`, returning a vector of
valid values and nils. If a value in `coll-a` passes `pred`, the value in the
corresponding location in `coll-b` will be included in the output vector.
Otherwise, that location will be set to `nil`.</pre></div><div class="public" id="var-neutralize-ends"><h3>neutralize-ends</h3><div class="usage"><code>(neutralize-ends bad-set reli-coll val-coll)</code></div><pre class="doc">replace the ends of a value-collection (like NDVI) with the mean of valid values
if the ends are unreliable, according to an associated reliability index, manifest
in `reli-coll`. If there are no bad values (as indicated by `bad-set` values in
`reli-coll`) then `neutralize-ends` will return the original time-series.
`bad-set` is a set of `reli-coll` values that indicate unreliable pixels.</pre></div><div class="public" id="var-reliable%3F"><h3>reliable?</h3><div class="usage"><code>(reliable? good-set good-min reli-ts)</code></div><pre class="doc">Checks whether the share of reliable pixels exceeds a supplied minimum.

This should be used to filter out pixels that are too unreliable for analysis, given
 that we use linear interpolation to replace unreliable periods. We have not hardcoded
 a specific threshold, but the papers below provide guidance:

0.8 reliable in de Beurs (2009) http://dx.doi.org/10.1088/1748-9326/4/4/045012
0.9 reliable in Verbesselt 2010 http://dx.doi.org/10.1016/j.rse.2010.08.003

Usage:

(reliable? #{0 1} 0.9 [0 0 0 1 1 0 1 1 0 0])
;=&gt; true

(reliable? #{0 1} 0.9 [0 0 0 2 2 0 1 1 0 0])
;=&gt; false</pre></div><div class="public" id="var-replace-index-set"><h3>replace-index-set</h3><div class="usage"><code>(replace-index-set idx-set new-val coll)</code></div><pre class="doc">replace values in `coll` with `new-val` for all indices in
`idx-set`</pre></div><div class="public" id="var-shorten-ts"><h3>shorten-ts</h3><div class="usage"><code>(shorten-ts model-ts ts)</code></div><pre class="doc">Shorten timeseries to length of model timeseries
</pre></div><div class="public" id="var-stretch-ts"><h3>stretch-ts</h3><div class="usage"><code>(stretch-ts ts [left right])</code></div><pre class="doc">stretch time-series across bad values if the left and right values of a
tuple are not sequential.  The original time-series is `ts` and the tuples
are a moving window (from `partition 2 1`) based on the valid values from
an associated time-series of reliability values.</pre></div><div class="public" id="var-tele-ts"><h3>tele-ts</h3><div class="usage"><code>(tele-ts start-index end-index base-seq)</code></div><pre class="doc">create a telescoping sequence of sequences, where each incremental sequence
is one element longer than the last, pinned to the same initial subsequence.

`start-index` is interpreted such that the first output sequence
includes all values up to but not including the value at `start-index`.
`end-index` is interpreted similarly for the final output sequence.

`start-index` &lt;= 0 will throw an exception to avoid returning empty vector</pre></div></div></body></html>